//
// name: LAPPD2.cc
// date: August 10, 2012
// author: Chien-Min Kao
// Description: programs to read and analyze root files generated by GATE
//                    for the dual-panel PET system
//

#include <fstream>
#include <iostream>
#include <cmath>
#include <stdio.h>
#include "PETscanner.h"

using namespace::std;

int main(int argc, char **argv)
{
	// check syntax
	if (argc<2)
	{
		cerr << "Usage: " << argv[0] << " <file1> <file2> ..." << endl;
		return 1;
	}

	// load the Tree library is not already loaded
	if (!TClassTable::GetDict("Tree")) gSystem->Load("libTree.so");

	// set energy and coincidence windows
	const int no_ew = 5;
	float lld[no_ew] = { 0.15, 0.25, 0.35, 0.45, 0.450 };
	float uld[no_ew] = { 0.65, 0.65, 0.65, 0.65, 0.572 };
	const int no_cw = 10;
	float cw[no_cw] = { 1e-9, 2e-9, 3e-9, 4e-9, 5e-9, 6e-9, 7e-9, 8e-9, 9e-9, 10e-9 };

	// prepare spaces for storing count statistics
	Long64_t *ntrue =    new Long64_t[no_ew*no_cw];
	Long64_t *nscatter = new Long64_t[no_ew*no_cw];
	Long64_t *nrandom =  new Long64_t[no_ew*no_cw];
	memset(ntrue, 0, sizeof(Long64_t)*no_ew*no_cw);
	memset(nscatter, 0, sizeof(Long64_t)*no_ew*no_cw);
	memset(nrandom, 0, sizeof(Long64_t)*no_ew*no_cw);

	// open rootfile
        for (int infile=1; infile<argc; ++infile)
        {
		cerr << "Processing " << argv[infile];
		TFile *file = new TFile(argv[infile]);
		if (file->IsZombie())
		{
			cerr << "ERROR: open " << argv[infile] << " failed" << endl;
			return 2;
		}
			
		// setup access
		Coincidence c(file);
		cerr << " (" << c.GetNoOfEntries() << " entries) ..." << flush;

		// get count statistcs  
		for (Long64_t n=0; n<c.GetNoOfEntries(); ++n)
		{
			// read a coincidence event
	     		c.Fetch(n);
		
 			// loop through energy windows
			for (int idx_ew=0; idx_ew<no_ew; ++idx_ew)
			{
				// check if energy qualified
				if (!c.IsQualified(lld[idx_ew], uld[idx_ew])) continue;
				for (int idx_cw=0; idx_cw<no_cw; ++idx_cw)
				{
					// check if coincidence window qualified
					if (!c.IsTOFWithin(cw[idx_cw])) continue;
					// update counts
					int idx_ct = idx_cw + idx_ew*no_cw;
					if (c.IsRandom()) nrandom[idx_ct]++;
			                else if (c.IsScattered()) nscatter[idx_ct]++;
			                else ntrue[idx_ct]++;
				}
			}
		}
		// done with this input file
		file->Close();
	}

	// write count statistics
	for (int idx_ew=0; idx_ew<no_ew; ++idx_ew)
	{
		cout << lld[idx_ew]*1000 << "-" << uld[idx_ew]*1000 << "keV" << endl;
		for (int idx_cw=0; idx_cw<no_cw; ++idx_cw)
		{
			cout << cw[idx_cw]*1e12 << " ";
			int idx_ct = idx_cw + idx_ew*no_cw;
			cout << Long64_t(ntrue[idx_ct]) << " ";
			cout << Long64_t(nscatter[idx_ct]) << " ";
			cout << Long64_t(nrandom[idx_ct]) << endl;
		}
	}

	// done
	return 0;
}
